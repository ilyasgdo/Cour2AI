# -*- coding: utf-8 -*-
"""TD_3I-SI4-Algorithmes-évolutionnaires_ILYAS_GHANDAOUI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14y1O84dO4p6U2MU2wpWQSr3eyvJ0RJB2

# Introduction à l'IA
##TD_3I-SI4 : Algorithmes évolutionnaires

## ILYAS GHANDAOUI E3FI 1I


"""
import numpy as np
import random
import math

matrice_interventions = np.array([
    [5, 2, 4, 8, 9, 0, 3, 3, 8, 7],
    [5, 5, 3, 4, 4, 6, 4, 1, 9, 1],
    [4, 1, 2, 1, 3, 8, 7, 8, 9, 1],
    [1, 7, 1, 6, 9, 3, 1, 9, 6, 9],
    [4, 7, 4, 9, 9, 8, 6, 5, 4, 2],
    [7, 5, 8, 2, 5, 2, 3, 9, 8, 2],
    [1, 4, 0, 6, 8, 4, 0, 1, 2, 1],
    [1, 5, 2, 1, 2, 8, 3, 3, 6, 2],
    [4, 5, 9, 6, 3, 9, 7, 6, 5, 10],
    [0, 6, 2, 8, 7, 1, 2, 1, 5, 3]
])
hauteur, largeur = matrice_interventions.shape
total_operations = matrice_interventions.sum()

class Individu:
    def __init__(self, x=None, y=None):
        self.x = x if x is not None else random.randint(0, largeur - 1)
        self.y = y if y is not None else random.randint(0, hauteur - 1)
        self.adaptation = 0
    def calculer_adaptation(self):
        j, i = np.meshgrid(np.arange(largeur), np.arange(hauteur))
        distances = np.sqrt((self.x - j) ** 2 + (self.y - i) ** 2)
        cout_total = np.sum(matrice_interventions * distances)

        print(f"cout total: {cout_total}")
        self.adaptation = cout_total / total_operations
        return self.adaptation



def croisement(parent1, parent2):
    """crée deux enfants par échange de coordonnées (Y1 et Y2)"""
    enfant1 = Individu(parent1.x, parent2.y)
    enfant2 = Individu(parent2.x, parent1.y)
    return enfant1, enfant2


def mutation(individu, prob_mutation=0.7):
    #mutation de x avec probabilité prob_mutation/2
    if random.random() < prob_mutation / 2:
        individu.x = np.clip(individu.x + random.choice([-1, 1]), 0, largeur - 1)

    #mutation de y avec probabilité prob_mutation/2
    if random.random() < prob_mutation / 2:
        individu.y = np.clip(individu.y + random.choice([-1, 1]), 0, hauteur - 1)

    return individu

def algorithme_evolutionnaire():
    taille_population = 5999
    population = [Individu() for _ in range(taille_population)]
    meilleur_historique = None
    generation = 0

    while True:
        for individu in population:
            individu.calculer_adaptation()
        population.sort(key=lambda x: x.adaptation)
        meilleur_actuel = population[0]

        if meilleur_historique and np.linalg.norm([meilleur_actuel.x - meilleur_historique.x,meilleur_actuel.y - meilleur_historique.y]) <= 0.001:
            print(f"Convergence à la génération {generation}")
            break

        meilleur_historique = meilleur_actuel
        selectionnes = population[:int(taille_population * 0.2)]
        print(selectionnes)
        descendants = []
        while len(descendants) < taille_population - len(selectionnes):
            p1, p2 = random.choices(selectionnes, k=2)
            e1, e2 = croisement(p1, p2)
            descendants.append(mutation(e1))
            descendants.append(mutation(e2))

        population = selectionnes + descendants[:taille_population - len(selectionnes)]
        generation += 1

    return meilleur_historique

solution_optimale = algorithme_evolutionnaire()
print(f"Position optimale: ({solution_optimale.x}, {solution_optimale.y})")
print(f"Coût moyen: {solution_optimale.adaptation:.2f} km/intervention")



import random
def generate_random_individual():
    """cree  un individu valide (permutation des chiffres 1 à 8)"""
    return random.sample(range(1, 9), 8)



def cost_function(individual):
    """Calcule nb conflits dans l'individu"""
    conflicts = 0
    n = len(individual)

    for i in range(n):
        for j in range(i + 1, n):
            if abs(individual[i] - individual[j]) == abs(i - j):
                conflicts += 1

    return conflicts


def crossover(parent1, parent2):

    #découpage en segments
    seg_p1_1 = parent1[:3]
    seg_p1_2 = parent1[3:5]
    seg_p1_3 = parent1[5:]

    seg_p2_1 = parent2[:3]
    seg_p2_2 = parent2[3:5]
    seg_p2_3 = parent2[5:]

    #sélection aléatoire des segments (segment 2 inversé)
    segment1 = seg_p1_1 if random.random() < 0.5 else seg_p2_1
    segment2 = seg_p1_2[::-1] if random.random() < 0.5 else seg_p2_2[::-1]
    segment3 = seg_p1_3 if random.random() < 0.5 else seg_p2_3

    #combinaison des segments pour former le nouvel individu
    new_individual = segment1 + segment2 + segment3

    return new_individual



def mutate(individual):
    """Effectue une mutation en échangeant deux valeur à la position 1 et 5 dans la permutation."""
    n = len(individual)
    i=1
    j =5
    individual[i], individual[j] = individual[j], individual[i]
    return individual

"""Algorithme génétique pour trouvé une permutation de 8 reines sans conflit"""

def genetic_algorithm(max_iterations=5000000):
    """cherche une solution au problème des 8 reines """
    best_individual = generate_random_individual()
    best_cost = cost_function(best_individual)

    for iteration in range(max_iterations):
        if best_cost == 0:
            print(f"solution trouvée en {iteration} itérations : {best_individual}")
            return best_individual

        partner = generate_random_individual()

        new_individual = crossover(best_individual, partner)

        if random.random() < 0.5:
            new_individual = mutate(new_individual)

        new_cost = cost_function(new_individual)

        if new_cost < best_cost:
            best_individual = new_individual
            best_cost = new_cost


        print(f"Itération {iteration} : best coût = {best_cost} Individu = {best_individual}")

    print(f"Aucune solution trouvée après {max_iterations} itérations.")
    return None



genetic_algorithm()



COLORS = ['♠', '♥', '♦', '♣']

def create_individu():

    individu = []
    for v in range(1, 11):
        gene = {
            'value': v,
            'color': random.choice(COLORS),
            'group': None
        }
        individu.append(gene)

    indices = list(range(10))
    random.shuffle(indices)
    product_indices = indices[:5]
    for i in range(10):
        if i in product_indices:
            individu[i]['group'] = 'product'
        else:
            individu[i]['group'] = 'sum'
    return individu



def evaluer_cout(individu):

    product_value = 1
    sum_value = 0
    for gene in individu:
        v = gene['value']
        if gene['group'] == 'product':
            product_value *= v
        elif gene['group'] == 'sum':
            sum_value += v
    cost = abs(product_value - 360) + abs(sum_value - 36)
    return cost



def crossover(parent1, parent2):

    point_coupure = 5
    enfant = []


    for i in range(10):
        if i < point_coupure:
            gene = parent1[i].copy()
        else:
            gene = parent2[i].copy()
        enfant.append(gene)


    #correction si la répartition des groupes n'est pas respectée
    prod_count = sum(1 for gene in enfant if gene['group'] == 'product')
    if prod_count != 5:
        if prod_count > 5:
            #trop de cartes en 'product': on en change quelques-unes en 'sum'
            indices = [i for i, gene in enumerate(enfant) if gene['group'] == 'product']
            change = random.sample(indices, prod_count - 5)
            for i in change:


                enfant[i]['group'] = 'sum'

        else:
            #trop peu de cartes en 'product': on change quelques cartes 'sum' en 'product'
            indices = [i for i, gene in enumerate(enfant) if gene['group'] == 'sum']
            change = random.sample(indices, 5 - prod_count)
            for i in change:

                enfant[i]['group'] = 'product'
    return enfant



def muter(individu, mutation_rate_color=0.1, mutation_rate_group=0.1):

    for gene in individu:
        if random.random() < mutation_rate_color:

            current_color = gene['color']
            new_colors = [c for c in COLORS if c != current_color]

            gene['color'] = random.choice(new_colors)

    if random.random() < mutation_rate_group:

        prod_indices = [i for i, gene in enumerate(individu) if gene['group'] == 'product']
        sum_indices = [i for i, gene in enumerate(individu) if gene['group'] == 'sum']

        if prod_indices and sum_indices:

            i = random.choice(prod_indices)
            j = random.choice(sum_indices)

            individu[i]['group'], individu[j]['group'] = individu[j]['group'], individu[i]['group']

    return individu

"""Code d'alorithme génétique"""

def tournois(population, fitnesses, k=2):

    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]


def select_parents(population, fitnesses):

    parent1 = tournois(population, fitnesses)
    parent2 = tournois(population, fitnesses)
    return parent1, parent2


def genetic_algorithm(pop_size=99, generations=5555):

    population = [create_individu() for _ in range(pop_size)]
    best = None
    best_cost = math.inf

    for gen in range(generations):
        fitnesses = [evaluer_cout(ind) for ind in population]

        for ind, cost in zip(population, fitnesses):
            if cost < best_cost:
                best = ind
                best_cost = cost

        if best_cost == 0:
            print(f"Solution trouvée à la génération {gen} avec un coût de {best_cost}.")
            return best

        new_population = []
        while len(new_population) < pop_size:
            parent1, parent2 = select_parents(population, fitnesses)
            enfant = crossover(parent1, parent2)
            enfant = muter(enfant)
            new_population.append(enfant)
        population = new_population


        print(f"Génération {gen}, meilleur coût jusqu'à présent: {best_cost}")

    print("Aucune solution parfaite n'a été trouvée.")
    return best


def print_individu(individu):

    prod_values = [gene['value'] for gene in individu if gene['group'] == 'product']
    sum_values = [gene['value'] for gene in individu if gene['group'] == 'sum']

    product_result = math.prod(prod_values)
    sum_result = sum(sum_values)

    print("Groupe 'product' :", prod_values, "Produit =", product_result)
    print("Groupe 'sum'     :", sum_values, "Somme =", sum_result)
    print("Détails de l'individu :")
    for gene in individu:
        print(f"Valeur : {gene['value']:2} | Couleur : {gene['color']} | Groupe : {gene['group']}")



"""###################### Exo 1 #########################"""
genetic_algorithm()
print("\n")
print("\n")
print("\n")
"""###################### Exo 2 #########################"""
solution_optimale = algorithme_evolutionnaire()
print(f"Position optimale: ({solution_optimale.x}, {solution_optimale.y})")
print(f"Coût moyen: {solution_optimale.adaptation:.2f} km/intervention")
print("\n")
print("\n")
print("\n")
"""###################### Exo 3 #########################"""
best_solution = genetic_algorithm(pop_size=200, generations=5000)
print("\nmeilleure solution trouvée :")
print_individu(best_solution)